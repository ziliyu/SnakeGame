import { DispatcherBase, EventListBase } from "ste-core";
import { IEventHandler, IEvent, IEventHandling } from "./definitions";
/**
 * Dispatcher implementation for events. Can be used to subscribe, unsubscribe
 * or dispatch events. Use the ToEvent() method to expose the event.
 */
export declare class EventDispatcher<TSender, TArgs> extends DispatcherBase<IEventHandler<TSender, TArgs>> implements IEvent<TSender, TArgs> {
    /**
     * Creates a new EventDispatcher instance.
     */
    constructor();
    /**
     * Dispatches the event.
     * @param sender The sender.
     * @param args The arguments object.
     */
    dispatch(sender: TSender, args: TArgs): void;
    /**
     * Dispatches the events thread.
     * @param sender The sender.
     * @param args The arguments object.
     */
    dispatchAsync(sender: TSender, args: TArgs): void;
    /**
     * Creates an event from the dispatcher. Will return the dispatcher
     * in a wrapper. This will prevent exposure of any dispatcher methods.
     */
    asEvent(): IEvent<TSender, TArgs>;
}
/**
 * Similar to EventList, but instead of TArgs, a map of event names ang argument types is provided with TArgsMap.
 */
export declare class NonUniformEventList<TSender, TArgsMap extends {
    [event: string]: any;
}> {
    private _events;
    /**
     * Gets the dispatcher associated with the name.
     * @param name The name of the event.
     */
    get<K extends keyof TArgsMap>(name: K): EventDispatcher<TSender, TArgsMap[K]>;
    /**
     * Removes the dispatcher associated with the name.
     * @param name The name of the event.
     */
    remove(name: string): void;
    /**
     * Creates a new dispatcher instance.
     */
    protected createDispatcher<T>(): EventDispatcher<TSender, T>;
}
/**
 * Storage class for multiple events that are accessible by name.
 * Events dispatchers are automatically created.
 */
export declare class EventList<TSender, TArgs> extends EventListBase<EventDispatcher<TSender, TArgs>> {
    /**
     * Creates a new EventList instance.
     */
    constructor();
    /**
     * Creates a new dispatcher instance.
     */
    protected createDispatcher(): EventDispatcher<TSender, TArgs>;
}
/**
 * Extends objects with event handling capabilities.
 */
export declare abstract class EventHandlingBase<TSender, TArgs> implements IEventHandling<TSender, TArgs> {
    private _events;
    /**
     * Gets the list with all the event dispatchers.
     */
    protected get events(): EventList<TSender, TArgs>;
    /**
     * Subscribes to the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    subscribe(name: string, fn: IEventHandler<TSender, TArgs>): void;
    /**
     * Subscribes to the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    sub(name: string, fn: IEventHandler<TSender, TArgs>): void;
    /**
     * Unsubscribes from the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    unsubscribe(name: string, fn: IEventHandler<TSender, TArgs>): void;
    /**
     * Unsubscribes from the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    unsub(name: string, fn: IEventHandler<TSender, TArgs>): void;
    /**
     * Subscribes to once the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    one(name: string, fn: IEventHandler<TSender, TArgs>): void;
    /**
     * Subscribes to once the event with the specified name.
     * @param name The name of the event.
     * @param fn The event handler.
     */
    has(name: string, fn: IEventHandler<TSender, TArgs>): boolean;
}
